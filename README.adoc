= SWAMP SARIF IO Libraries

////
https://github.com/mirswamp/swamp-sarif-io
SWAMP: https://continuousassurance.org

Copyright 2018 Yuan Zhe Bugh, James A. Kupsch

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the Lincense is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and 
limitations under the License.
////
Module Version: 0.8.5

Last updated on 03-06-2019

Sarif version currently tracking: sarif-2.0.0-csd.2.beta.2019-01-09

=== Name
swamp-sarif-io - Library to write SARIF files from Perl

=== Description
The https://continuousassurance.org[Software Assurance Marketplace (SWAMP)] runs software assurance tools, and converts the results of each tool into a common format called SCARF (SWAMP Common Assessment Result Format). There is now a new format being developed by https://www.oasis-open.org[OASIS] called https://github.com/oasis-tcs/sarif-spec[SARIF]. This repository contains a set of libraries that allows a program to write SARIF data from programs written in Perl. 

Documentation for SCARF is available https://github.com/mirswamp/swamp-scarf-io/blob/master/docs/SCARF.pdf[here].
Documentation for SARIF is available https://github.com/oasis-tcs/sarif-spec/tree/master/Documents/ProvisionalDrafts[here].

=== Synopsis
An example of a normal usage where the assessment ran successfully:
[source,perl]
----
use SarifJsonWriter;

my $output = "/path/to/file.sarif"
my $writer = new SarifJsonWriter($output, "utf-8");

my %optionsData = (
  pretty => 1,
  external => {
    results => {
      name => "results.sarif-external-properties",
      maxItems => 1000,
    },
  },
)
$writer->SetOptions(\%optionsData);

my @errors = ();
push @errors, CheckInitialData($initialData);
push @errors, CheckInvocations($invocations);
push @errors, CheckResultData($resultData);
push @errors, CheckRuleData($ruleData);

$writer->BeginFile();
$writer->BeginRun($initialData);
$writer->AddOriginalUriBaseIds($baseIds);
$writer->AddInvocations($invocations);
$writer->BeginResults();
$writer->AddResult($resultData);
$writer->EndResults();
$writer->AddResources($ruleData);
$writer->EndRun($endData);
$writer->EndFile();
----
An example usage where the assessment failed to run:
[source, perl]
----
use SarifJsonWriter;

my $output = "/path/to/file.sarif"
my $writer = new SarifJsonWriter($output, "utf-8");

$writer->SetPretty(1);

$writer->AddFailure($failureData);
----

=== Output
Significant SARIF properties included in the generated SARIF files:
----
{
  version: "...",
  $schema: "...",
  runs: [
    {
      id: {
        instanceGuid: "...",
      },
      tool: {
        name: "...",
        version: "...",
      },
      properties: { ... },
      originalUriBaseIds: { ... },
      invocations: [
        commandLine: "...",
        arguments: [ ... ],
        startTimeUtc: "...",
        endTimeUtc: "...",
        workingDirectory: { ... },
        environmentVariables: { ... },
        exitCode: "..."
      ],
      results: [
        {
          ruleId: "...",
          level: "...",
          rank: "...",
          message: { ... },
          locations: [ ... ], # including line, column, snippets
          codeFlows: [ ... ],
          provenance: { ... },
          properties: { tags: [], ... },
        }, ...
      ]
      files: [ ... ],
      conversion: { ... },      
    }, ...
  ]
}
----

=== Requirements
The following Perl libraries should be installed for the program to work correctly:

- JSON::Streaming::Writer

=== Subroutines

==== new($output_file, $encoding)
This is the subroutine used to instantiate the writer. This subroutine expects two parameters, which are the output file name and the encoding. Only the "utf-8" encoding is supported right now.

==== SetOptions($optionsData)
Sets options for the writer. Current options supported includes whether the writer pretty prints (meaning add indentation), setting the error level and to set which properties will be externalized.

Error level sets how the program handle errors. 0 means do nothing; 1 means just print the error; 2 means print the error and die. 2 is the default value.

If an external property has a set max size, the external property file that contains this external property cannot contain an external property other than this external property.

==== GetPretty()
Returns a boolean that shows whether the writer currently pretty prints. 0 (false) is the default.

==== GetErrorLevel()
Returns the error level currently set. 2 is the default value.

==== BeginFile()
Starts writing some initial properties to the SARIF file.

==== BeginRun($initialData)
This subroutine writes to the SARIF file data that applies to the whole assessment.

==== AddOriginalUriBaseIds($baseIds)
Adds the originalUriBaseIds property to the SARIF file.

==== AddInvocations($invocations)
Note: AddOriginalUriBaseIds($baseIds) must be called first before AddInvocations($invocations) can be called. This is because paths in the workingDirectory object adjusts to the path set in AddOriginalUriBaseIds($baseIds).

This subroutine adds the invocation property.

==== BeginResults()
Starts the results property and array. Called once before AddResult($resultData).

==== AddResult($resultData)
Every BugInstance in a SCARF file maps to a result object in SARIF. This subroutine writes necessary data for a result object, as well as storing some data that will be written after all result objects are written.

==== EndResults()
Ends the results property and array. Called once after all AddResult($resultData) calls.

==== AddResources($ruleData)
Adds the resources object.

==== EndRun($endData)
Data saved previously will be written out here. Also ends the run object.

==== EndFile()
Ends arrays and properties and closes all files opened.

==== CheckInitialData($initialData)
Checks whether the required fields in the data structure are set. Program either does nothing, just print errors or dies depending on the error level set.

==== CheckInvocations($invocations)
Checks whether the required fields in the data structure are set. Program either does nothing, just print errors or dies depending on the error level set.

==== CheckResultData($bugData)
Checks whether the required fields in the data structure are set. Program either does nothing, just print errors or dies depending on the error level set.

==== CheckRuleData($ruleData)
Checks whether the required fields in the data structure are set. Program either does nothing, just print errors or dies depending on the error level set.

==== AddFailure($failureData)
The only method to call after new() when there is a failure. This subroutine writes a sarif file containing only the conversion object in the run object. Inside the conversion object is the property "toolNotifications" which will contain the error message.

=== Data Structures
The following are the data structures used in the callbacks listed above:

==== $optionsData
optionsData contains information that is supposed to be passed to the writer at the beginning for the purpose of configuring the writer.

----
{
  pretty             => PRETTY_VALUE (Default is false),
  error_level        => ERROR_LEVEL_VALUE (Default is 2),
  external => {
    $PROPERTY_NAME => {
      name           => NAME_VALUE,
      maxItems       => MAX_ITEMS_VALUE,    # Only for properties that contain arrays
    },
  }
}
----

==== $initialData
initialData contains information regarding the assessment. 
----
{
  build_root_dir     => PACKAGE_DIRECTORY,                        # REQUIRED
  package_root_dir   => DIRECTORY_CONTAINING_PACKAGE,             # REQUIRED
  results_root_dir   => DIRECTORY_CONTAINING_ASSESSMENT_REPORTS,  # REQUIRED
  uuid               => UUIDVALUE,                                # REQUIRED
  tool_name          => TOOL_NAME,                                # REQUIRED
  tool_version       => TOOL_VERSION,                             # REQUIRED
  package_name       => PACKAGE_NAME,                             # REQUIRED
  package_version    => PACKAGE_VERSION                           # REQUIRED
  buildDir           => BUILD_DIR_PATH
}
----

==== $baseIds
----
{
  PACKAGEROOT        => PACKAGE_ROOT_VALUE,                 # REQUIRED
  RESULTSROOT        => RESULTS_ROOT_VALUE,
}
----

==== $invocations
This hash contains the information related to the invocation(s) of the tool
----
{
  packageRootDir            => PACKAGE_ROOT_DIR_VALUE,
  assessments => [
    {
      commandLine           => COMMAND_LINE_VALUE,
      startTime             => INVOCATION_START_TIME,
      endTime               => INVOCATION_END_TIME,
      workingDirectory      => WORKING_DIRECTORY,
      exitCode              => EXIT_CODE_VALUE,
      args => [
        'ARG1', 'ARG2', ...  # ARGUMENTS
      ], 
      env => {               # ENVIRONMENT_VARIABLES
        'key1' => 'value1',
        'key2' => 'value2',
        ...
      },
      report                => ASSESSMENT_REPORT_FILE
    },
    ...
  ]
}
----

==== $resultData
Each resultData hash contains information for one result object. Fields marked as required must be present. If both BugGroup and BugCode are not present, the ruleId for the corresponding result object in sarif will be set to "\___UNKNOWN___".
----
{
  BugGroup              => GROUP_VALUE,
  BugCode               => CODE_VALUE,
  BugRank               => RANK_VALUE,
  BugMessage            => BUG_MESSAGE_VALUE,           # REQUIRED
  BugLocations  => [
    {
      SourceFile        => SOURCE_FILE_NAME,            # REQUIRED
      StartLine         => START_LINE,
      EndLine           => END_LINE,
      StartColumn       => START_COLUMN,
      EndColumn         => END_COLUMN,
      primary           => PRIMARY_VALUE,
      Explanation       => EXPLANATION_VALUE
    },
    ...
  ],
  AssessmentReportFile  => ASSESSMENT_REPORT_FILE_NAME, # REQUIRED
  BuildId               => BUILD_ID_VALUE,              # REQUIRED
  ClassName             => CLASS_NAME_VALUE,
  Methods => [
    {
      name              => METHODNAMEVALUE,             
    },
    ...
  ],
  BugSeverity           => SEVERITY_VALUE,
  CweIds => [
    CWEIDVALUE, CWEIDVALUE, ...
  ],
}
----

==== $ruleData
This hash contains information required to write the rules object in the run.resources property.
----
[
  {
    id                  => ID_VALUE,            # REQUIRED
    defaultLevel        => DEFAULT_LEVEL,       
    defaultRank         => DEFAULT_RANK,        
    shortDescription    => SHORT_DESCRIPTION,
    fullDescription     => FULL_DESCRIPTION,    # REQUIRED
  },
  ...
]
----

==== $endData
This hash contains information required to write out the final objects in the sarif file
----
{
  sha256hashes          => (SEE_BELOW),
  conversion            => (SEE_BELOW),
}
----

==== $sha256hashes
This hash contains the sha256 hashes for all files used in the assessment.
----
{
  /path/to/file1 => SHA256 VALUE FOR FILE1,
  /path/to/file2 => SHA256 VALUE FOR FILE2,
  ...
}
----

==== $conversion
This hash contains information required to write the conversion object in SARIF. All fields are required.
----
{
  tool_name             => TOOL_NAME,
  tool_version          => TOOL_VERSION,
  commandLine           => PROGRAM_NAME,
  workingDirectory      => WORKING_DIRECTORY,
  argv => [
    'ARG1', 'ARG2', ...  # ARGUMENTS
  ],
  env => {               # ENVIRONMENT_VARIABLES
    'key1' => 'value1',
    'key2' => 'value2',
    ...
  }
  startTime             => PROGRAM_START_TIME
}
----

==== $failureData
This hash contains all the information needed to write to a sarif file in the case that the converter finds that the assessment failed. All fields listed below are required.
----
{
  conversion            => (SEE ABOVE),                 # REQUIRED
  tool => {
    tool_name           => TOOL_NAME,                   # REQUIRED
  },
  message               => ERROR_MESSAGE                # REQUIRED
}
----